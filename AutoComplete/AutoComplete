AutoComplete

1. Requirements -
	* While user is typing to search, the system should suggest top 10 terms matching prefix with so far typed string.
	* 50ms wait after each key stroke to fire the query API.

2. Requirements Questions -
	* Should this suggestion list be different per user demographic, geo location, may be idividual user or current major event?

3. Underlying Systems - 
	* Let's think our system similar to google's search page where millions of search requested everyday. 
	* A distributed logging system logs each search.
	* A distribute Ranking system reads the log file
		* Ranks each term by let's say Frequency and a weight of recentness.
		* Produces list of fils containing terms with associated rank values.
		* These term-rank list files are distributed in multiple servers.
		* Each term is unique across all files all servers.
		* These term-rank list containing files are raw input for our AutoComplete System
		* If this Ranking system can provide term-rank list in lexicographically sorted order that good otherwise AutoComplete system will have to do it for its own.

4. Here comes our AutoComplete System - 

	1. A cluster of servers read given raw term-rank files and produce Sub-Ordered-Term-Rank file for each of these raw files.
		* Terms are lexicographically sorted within each Sub-Ordered-Term-Rank file.
		* Each Sub-Ordered-Term-Rank file data is published to a topic in a PUB/SUB system in order.

	2. Another Server reads chunks of data from all the topics and maintain a Min Heap to produce "Final-Ordered-Terms"
		* The chunk size can vary based on this server's capacity.
		* As long every topic has one representing chunk in this server then the Min Heap output will be sorted across all topics.
		* The "Final-Ordered-Terms" stream will be published to another topic for further processing.
		* This server can be SPOF, how to solve it -
			* We can have a cluster/series of such servers.
			* All the live servers in this cluster will be marked with a sequence number 1,2,3...n.
			* Each PUB/SUB topic must be subscribed by one and only one of these servers.
			* The nth Server's (n!=1) output will an input to the (n-1)th server.
			* The output of the 1st server (primary server) is the final stream of "Final-Ordered-Terms"
			* If a server goes down - 
				* We have to re-sequence the remaining servers.
				* The unattended topics needs to be subscribed by any remaining servers.

	3. We will have cluster or servers keeoing a Trie datastructure in memory.
		* A Processor server will keep reading from "Final-Ordered-Terms" and start filling the Trie server.
		* Once the 1st server is filled with a range of terms from the ordered term list it will be marked with this range lets say (a-aaabbc). The last node on this trie will keep a pointer to the next server as well.
		* Then the processer will start filling terms in the 2nd server and so on.
		* How these trie look -
			* It will be bunch of TrieNode in momory.
			* Each node will have 
				* Map<Character, TrieNode> children; // to travel down the tree using char from each positions
				* boolean isEndOfTerm // flag to mark end of a term
				* int Rank; // rank value if end of term is true
				* TrieNode[] topTenDescendentTerms; // top ranked descendant nodes that 
				
			* Root node's Map will 
			* End of term Flag. If true the Rank of the term
			* A Map pointing to children node mapped by next charecters
	